{
    "docs": [
        {
            "location": "/",
            "text": "RxTender is framework to implement code generators of remote reactive streams.\nWith RxTender, inter-process and inter-machine communication with reactive\nstreams is very easy. The idea of RxTender came after trying many IPC and RPC\nprotocols and code generators. Some of them were flexible but non productive to\nuse, while others were easy to use but too restricted.\n\n\nRxTender is based on the idea of allowing implementing Reactive Stream APIs\nover inter-process and network communication for any language, any transport\nprotocol, and any serialization. One of the main benefits of RxtTender is that\nyou can easily extend it for your developement environment and save a lot of\ntime.",
            "title": "Introduction"
        },
        {
            "location": "/rationale/",
            "text": "RxTender is built on the following ideas:\n\n\n\n\nAn IDL is used to specify reactive streams.\n\n\nThere is a clear separation between:\n\n\ntransport\n\n\nframing\n\n\nserialization    \n\n\nstream definition\n\n\n\n\n\n\nIt is possible to generate source and sink streams.\n\n\nIt is easy to add support for new programming languages, serialization and framing protocols.\n\n\nThe transport layer is not managed by RxTenders.\n\n\n\n\nThese ideas are summarized on the following figure showing a typical usage of\nRxTender where two services communicate with a reactive stream:",
            "title": "Rationale"
        },
        {
            "location": "/get_started/",
            "text": "This is the \"not so short\" getting started tutorial of RxTender. In this\ntutorial you will learn to use reactive streams to communicate between python\nand javascript code.\n\n\nLet's consider the following situation: Your team develops a product that is\ncomposed of two services, using different programming languages (javascript and\npython). You use Reactive Streams in both components and you need to communicate\nbetween them. This is exactly where RxTender can help you: Generate reactive\nstreams bindings between your services.\n\n\nYour user story is the following one:\n\n\nAs an end user using a terminal console I use a command line application to\ncount from 1 to 10. Since such a computation is very complex, this CLI\napplication asks another service to do it.\n\n\nYou ended up with the following technical choices:\n\n\n\n\nThe client application is developed in javascript/NodeJS.\n\n\nThe server is developed in python.\n\n\nTCP is used as a transport protocol.\n\n\nJSON is used as a serialization protocol.\n\n\nJSON lines us used as a framing protocol.\n\n\n\n\nStream Definition\n\n\nThe first thing to do is to write the stream specifications. We want 3 arguments\nto create our counter: Its initial value, its end value, and its increase step.\nThe stream specification is written in an IDL whose syntax is heavily inspired\nfrom rust. Save the following code to a file named \"counter.rxt\":\n\n\nstruct CounterItem {\n    value: i32;\n}\n\nstruct CounterError {\n    message :string;\n}\n\nstream Counter(start: i32, end: i32, step: i32) -> Stream<CounterItem, CounterError>;\n\n\n\n\nFirst there is the definition of the type of items that are emitted on the\nstream. They are named \"CounterItem\" and contain a single field named \"value\".\nThe type of this field is a signed 32 bits integer (i32).\n\n\nThen there is the definition of the error type associated to the stream. The\nCOunterError struct contains a single string field named \"message\".\n\n\nFinally there is the definition of the stream. It is named \"Counter\". It takes 3\ncreation arguments: start, end, and step. This stream will emit items of type\nCounterItem, and raise errors of type CounterError.\n\n\nThe python server\n\n\nNow let's code the python server, based on asyncio. We first start from a sample\nasyncio TCP server:\n\n\nimport asyncio\n\nclass CounterServerProtocol(asyncio.Protocol):\n    def connection_made(self, transport):\n        peername = transport.get_extra_info('peername')\n        print('Connection from {}'.format(peername))\n\n    def connection_lost(self, exc):\n        print('connection lost')\n        return\n\n    def data_received(self, data):\n        return\n\nloop = asyncio.get_event_loop()\n# Each client connection will create a new protocol instance\ncoro = loop.create_server(CounterServerProtocol, '127.0.0.1', 9999)\nserver = loop.run_until_complete(coro)\n\nprint('Serving on {}'.format(server.sockets[0].getsockname()))\ntry:\n    loop.run_forever()\nexcept KeyboardInterrupt:\n    pass\n\nserver.close()\nloop.run_until_complete(server.wait_closed())\nloop.close()\n\n\n\n\nEach time a client connects to the server, a new CounterServerProtocol object is\ncreated and its \"connection_made\" method is called. The first thing to do is\nimporting the definitions we will need:\n\n\nimport asyncio\n\n+from rx import Observable\n+from counter_rxt import frame, unframe, Router, CounterItem\n\n\n\n\nNote that we use RxPy here, but we could use other reactive stream libraries.\nThe we must provide a factory function to create the counter stream when a\nrequest is received from the network:\n\n\n+Router.set_Counter_factory(create_counter_stream)\nloop = asyncio.get_event_loop()\n# Each client connection will create a new protocol instance\n\n\n\n\n\"Router.set_Counter_factory\" is a static method of the Router class. RxTender\ngenerates one of these methods per stream declared in the rxt file. We will\nwrite the create_counter_stream function later. We will now create a Router\nobject each time a new connection is made:\n\n\ndef connection_made(self, transport):\n    peername = transport.get_extra_info('peername')\n    print('Connection from {}'.format(peername))\n+    self.router = Router(FramedTransport(transport))\n+    self.frame_context = ''\n\n\n\n\nThe router object contains the implementation that routes network messages\nto/from streams. It is also in charge of (de)serializing these messages. Its\nconstructor takes a transport object as an argument. This transport object must\nimplement a \"write\" method to write data on the network connection. Note that we\ndid not use the \"transport\" argument directly: Since we use TCP (a stream based\nprotocol), we need add framing on top of it so that we receive messages\ncorrectly. This is what is done by the FramedTransport class:\n\n\nclass FramedTransport(object):\n    def __init__(self, transport):\n        self.transport = transport\n\n    def write(self, data):\n        self.transport.write(frame(data).encode())\n\n\n\n\nIn the write method, each message is \"framed\" with the JSON-lines protocol\nbefore being sent. On the other way, all received packets are \"unframed\" before\nthey are provided to the Router:\n\n\ndef data_received(self, data):\n+    message = data.decode()\n+    self.frame_context, packets = unframe(self.frame_context, message)\n+    for packet in packets:\n+        self.router.on_message(packet)\n\n\n\n\nFrom that point we created a Router, it receives all messages from the network\nand can send messages. We finally need to implement create_counter_stream that\nwill be called each time a new stream subscription request comes:\n\n\ndef delete_counter_subscription(stream):\n    stream = None\n\ndef create_counter_stream(start, end, step):\n    source = Observable.from_(range(start,end+1, step)).map(\n        lambda i: CounterItem(i))\n    return lambda n,c,e: subscribe_counter_stream(source, n, c, e), lambda: delete_counter_subscription(source)\n\ndef subscribe_counter_stream(stream, next, completed, error):\n    stream.subscribe(\n        lambda i: next(i),\n        lambda e: error(e),\n        lambda: completed())\n\n\n\n\ncreate_counter_stream takes 3 arguments as input: The ones that we specified in the rxt file. It returns 2 functions:\n\n\n\n\nA function to subscribe to this stream\n\n\nA function to delete this stream\n\n\n\n\nThe subscription function is called with 3 function arguments (next, error,\ncompleted). Each time the corresponding event occurs on the source stream, then\nthese functions must be called to forward the event on the transport layer.\n\n\nHere is the complete code of the server. Save it to a file named \"server.py\":\n\n\nimport asyncio\n\nfrom rx import Observable\nfrom counter_rxt import frame, unframe, Router, CounterItem\n\nclass FramedTransport(object):\n    def __init__(self, transport):\n        self.transport = transport\n\n    def write(self, data):\n        self.transport.write(frame(data).encode())\n\nclass CounterServerProtocol(asyncio.Protocol):\n    def connection_made(self, transport):\n        peername = transport.get_extra_info('peername')\n        print('Connection from {}'.format(peername))\n        self.router = Router(FramedTransport(transport))\n        self.frame_context = ''\n\n    def connection_lost(self, exc):\n        print('connection lost')\n        return\n\n    def data_received(self, data):\n        message = data.decode()\n        self.frame_context, packets = unframe(self.frame_context, message)\n        for packet in packets:\n            self.router.on_message(packet)\n\ndef delete_counter_subscription(stream):\n    stream = None\n\ndef create_counter_stream(start, end, step):\n    source = Observable.from_(range(start,end+1, step)).map(\n        lambda i: CounterItem(i))\n    return lambda n,c,e: subscribe_counter_stream(source, n, c, e), lambda: delete_counter_subscription(source)\n\ndef subscribe_counter_stream(stream, next, completed, error):\n    stream.subscribe(\n        lambda i: next(i),\n        lambda e: error(e),\n        lambda: completed())\n\nRouter.set_Counter_factory(create_counter_stream)\nloop = asyncio.get_event_loop()\n# Each client connection will create a new protocol instance\ncoro = loop.create_server(CounterServerProtocol, '127.0.0.1', 9999)\nserver = loop.run_until_complete(coro)\n\nprint('Serving on {}'.format(server.sockets[0].getsockname()))\ntry:\n    loop.run_forever()\nexcept KeyboardInterrupt:\n    pass\n\nserver.close()\nloop.run_until_complete(server.wait_closed())\nloop.close()\n\n\n\n\nNodeJS client\n\n\nFor the nodejs client, we start with a TCP client, implemented as a function\nthat returns a stream of stream:\n\n\nimport {Observable, Subject} from 'rxjs';\nimport {Socket} from 'net';\nlet connection = [];\n\nfunction createConnection(id, host, port) {\n  const state$ = Observable.create(stateObserver => {\n    let dataObserver = null;\n    const data$ = Observable.create(observer => {\n      dataObserver = observer;\n    });\n\n    connection[id] = new Socket();\n    connection[id].setEncoding('utf8');\n    connection[id].connect(port, host, function() {\n        console.log('CONNECTED TO: ' + host + ':' + port);\n        stateObserver.next({\n          \"linkId\": id,\n          \"stream\": data$\n        })\n    });\n\n    connection[id].on('data', function(data) {\n      dataObserver.next(data);\n    });\n\n    connection[id].on('close', function() {\n        dataObserver.complete();\n        stateObserver.complete();\n        connection.splice(id, 1);\n    });\n  });\n\n  return state$;\n}\n\n\n\n\nThis function returns a stream that emits a stream when the connection is\nestablished. This latter stream then emits items each time some data is received\non the socket. This function is used from a factory function that takes another\nstream as input:\n\n\nfunction tcpClient(sink$) {\n  sink$.subscribe( (i) => {\n    connection[i.linkId].write(i.data);\n  });\n\n  return {\n    \"connect\" : createConnection\n  };\n}\n\n\n\n\nEach item of the sink stream contains the data to write on the tcp socket.\nWe will also use log function:\n\n\nfunction consoleDriver(sink$) {\n  sink$.subscribe( (i) => {\n    console.log('console: ' + i);\n  });\n}\n\n\n\n\nNow we can implement our logic:\n\n\nimport { router } from './counter_rxt.js';\n\nfunction main(sources) {\n  const linkRcv$ = sources.LINK.connect('counter', 'localhost', 9999);\n  const returnChannel$ = sources.ROUTER.linkData();\n  const console$ = sources.ROUTER.link()\n    .map( i => {\n      return sources.ROUTER.Counter(i.linkId, 1,10,1)\n    })\n    .mergeAll()\n    .map( i => i.value);;\n\n  return {\n   ROUTER: linkRcv$,\n   LINK: returnChannel$,\n   CONSOLE: console$\n  };\n}\n\n\n\n\nThe sources parameter contains objects returned by the tcp client factory, the\nconsole factory, and the router factory. This main function creates a Counter\nobservable when the tcp connection is established, i.e. when an item is emitted\non the sources.ROUTER.link() stream. The result of the counter is returned in\nthe CONSOLE field, and will be connected to the console output.\n\n\nAll streams are finally connected together:\n\n\nconst consoleProxy$ = new Subject();\nconst routerProxy$ = new Subject();\nconst linkProxy$ = new Subject();\n\nconst sources = {\n  CONSOLE: consoleDriver(consoleProxy$),\n  ROUTER: router(routerProxy$),\n  LINK: tcpClient(linkProxy$)\n};\n\nconst sinks = main(sources);\n\nsinks.ROUTER.subscribe(routerProxy$);\nsinks.LINK.subscribe(linkProxy$);\nsinks.CONSOLE.subscribe(consoleProxy$);\n\n\n\n\nHere is the complete code of the client. Save it to a file named\n\"client.es6.js\":\n\n\nimport {Observable, Subject} from 'rxjs';\nimport {\n  router,\n} from './counter_rxt.js';\nimport {Socket} from 'net';\n\nlet connection = [];\n\nfunction createConnection(id, host, port) {\n  const state$ = Observable.create(stateObserver => {\n    let dataObserver = null;\n    const data$ = Observable.create(observer => {\n      dataObserver = observer;\n    });\n\n    connection[id] = new Socket();\n    connection[id].setEncoding('utf8');\n    connection[id].connect(port, host, function() {\n        console.log('CONNECTED TO: ' + host + ':' + port);\n        stateObserver.next({\n          \"linkId\": id,\n          \"stream\": data$\n        })\n    });\n\n    connection[id].on('data', function(data) {\n      dataObserver.next(data);\n    });\n\n    connection[id].on('close', function() {\n        dataObserver.complete();\n        stateObserver.complete();\n        connection.splice(id, 1);\n    });\n  });\n\n  return state$;\n}\n\nfunction tcpClient(sink$) {\n  sink$.subscribe( (i) => {\n    connection[i.linkId].write(i.data);\n  });\n\n  return {\n    \"connect\" : createConnection\n  };\n}\n\nfunction consoleDriver(sink$) {\n  sink$.subscribe( (i) => {\n    console.log('console: ' + i);\n  });\n}\n\nfunction main(sources) {\n  const linkRcv$ = sources.LINK.connect('counter', 'localhost', 9999);\n  const returnChannel$ = sources.ROUTER.linkData();\n  const console$ = sources.ROUTER.link()\n    .map( i => {\n      return sources.ROUTER.Counter(i.linkId, 1,10,1)\n    })\n    .mergeAll()\n    .map( i => i.value);;\n\n  return {\n   ROUTER: linkRcv$,\n   LINK: returnChannel$,\n   CONSOLE: console$\n  };\n}\n\nconst consoleProxy$ = new Subject();\nconst routerProxy$ = new Subject();\nconst linkProxy$ = new Subject();\n\nconst sources = {\n  CONSOLE: consoleDriver(consoleProxy$),\n  ROUTER: router(routerProxy$),\n  LINK: tcpClient(linkProxy$)\n};\n\nconst sinks = main(sources);\n\nsinks.ROUTER.subscribe(routerProxy$);\nsinks.LINK.subscribe(linkProxy$);\nsinks.CONSOLE.subscribe(consoleProxy$);\n\n\n\n\nRunning it all\n\n\nNow that all code is there, let's start both components. We will first Build the\npython bindings. First install the base backend on your system:\n\n\npip3 install rxt-backend-base\n\n\n\n\nThen generate the proxy code corresponding to the Counter IDL:\n\n\nrxtender \\\n--framing rxt_backend_base.python3.framing.newline \\\n--serialization rxt_backend_base.python3.serialization.json \\\n--stream rxt_backend_base.python3.stream \\\n--input counter.rxt --output counter_rxt.py\n\n\n\n\nrxtender is invoked with 3 generation arguments (framing, serialization, and\nstream). Each parameter corresponds to an available code generator in the\nbackend.\n\n\nThen we build the javascript bindings. In order to ease generation and\ntranslation from es6 to es5 we use npm with babel:\n\n\nJavascript NPM package.json:\n\n\n{\n  \"name\": \"counter-example\",\n  \"version\": \"0.2.0\",\n  \"description\": \"es2015/python3 rxtender counter example\",\n  \"license\": \"MIT\",\n  \"main\": \"client.js\",\n  \"scripts\": {\n    \"generate:counter\": \"rxtender --framing rxt_backend_base.es2015.framing.newline --serialization rxt_backend_base.es2015.serialization.json --stream rxt_backend_base.es2015_rxjs.stream --input counter.rxt --output counter_rxt.es6.js\",\n    \"build:counter\": \"npm run generate:counter && babel --presets es2015 counter_rxt.es6.js --out-file counter_rxt.js\",\n    \"build:client\": \"npm run build:counter && babel --presets es2015 client.es6.js --out-file client.js\",\n    \"build\": \"npm run build:client\",\n    \"start\": \"node client.js\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"babel-cli\": \"^6.24.1\",\n    \"babel-core\": \"^6.25.0\",\n    \"babel-preset-es2015\": \"^6.24.1\",\n    \"rxjs\": \"^5.4.3\"\n  }\n}\n\n\n\n\nThe stream argument provided to rxtender generates an es2015 rxjs router\nfunction. Since we use a TCP connection, and TCP is a stream protocol, we need\nsome framing to encapsulate each item of the stream. Here we use new lines\nframing, as specified with the framing argument. With the serialization argument\nwe asked rxtender to generate json serialization of all structs defined in the\nIDL. To generate the code, install npm dependencies and run rxtender:\n\n\nnpm install\nnpm run build\n\n\n\n\nNow everything is ready, we can start the python server:\n\n\npython3 server.py\n\n\n\n\nand run the javascript client:\n\n\nnpm start\n\n\n\n\nYou should get the following output:\n\n\n> counter-example@0.2.0 start /Users/bipbip/Documents/devel/rxtender/test\n> node client.js\n\nCONNECTED TO: 127.0.0.1:9999\ncreating observable\ntick: 1\ntick: 2\ntick: 3\ntick: 4\ntick: 5\ntick: 6\ntick: 7\ntick: 8\ntick: 9\ntick: 10\ncompleted\n\n\n\n\nYeah! With only few lines of codes you used reactive streams to communicate\nbetween two processes written in different programming languages. You can now\nadd other streams in the rxt file. All these streams will be multiplexed in\nthe same socket. Moreover, if you want to change the serialization or framing\nprotocol, then you do not need to change anything in your code: Just select\nother ones when invoking rxtender.",
            "title": "Get Started"
        },
        {
            "location": "/get_started/#stream-definition",
            "text": "The first thing to do is to write the stream specifications. We want 3 arguments\nto create our counter: Its initial value, its end value, and its increase step.\nThe stream specification is written in an IDL whose syntax is heavily inspired\nfrom rust. Save the following code to a file named \"counter.rxt\":  struct CounterItem {\n    value: i32;\n}\n\nstruct CounterError {\n    message :string;\n}\n\nstream Counter(start: i32, end: i32, step: i32) -> Stream<CounterItem, CounterError>;  First there is the definition of the type of items that are emitted on the\nstream. They are named \"CounterItem\" and contain a single field named \"value\".\nThe type of this field is a signed 32 bits integer (i32).  Then there is the definition of the error type associated to the stream. The\nCOunterError struct contains a single string field named \"message\".  Finally there is the definition of the stream. It is named \"Counter\". It takes 3\ncreation arguments: start, end, and step. This stream will emit items of type\nCounterItem, and raise errors of type CounterError.",
            "title": "Stream Definition"
        },
        {
            "location": "/get_started/#the-python-server",
            "text": "Now let's code the python server, based on asyncio. We first start from a sample\nasyncio TCP server:  import asyncio\n\nclass CounterServerProtocol(asyncio.Protocol):\n    def connection_made(self, transport):\n        peername = transport.get_extra_info('peername')\n        print('Connection from {}'.format(peername))\n\n    def connection_lost(self, exc):\n        print('connection lost')\n        return\n\n    def data_received(self, data):\n        return\n\nloop = asyncio.get_event_loop()\n# Each client connection will create a new protocol instance\ncoro = loop.create_server(CounterServerProtocol, '127.0.0.1', 9999)\nserver = loop.run_until_complete(coro)\n\nprint('Serving on {}'.format(server.sockets[0].getsockname()))\ntry:\n    loop.run_forever()\nexcept KeyboardInterrupt:\n    pass\n\nserver.close()\nloop.run_until_complete(server.wait_closed())\nloop.close()  Each time a client connects to the server, a new CounterServerProtocol object is\ncreated and its \"connection_made\" method is called. The first thing to do is\nimporting the definitions we will need:  import asyncio\n\n+from rx import Observable\n+from counter_rxt import frame, unframe, Router, CounterItem  Note that we use RxPy here, but we could use other reactive stream libraries.\nThe we must provide a factory function to create the counter stream when a\nrequest is received from the network:  +Router.set_Counter_factory(create_counter_stream)\nloop = asyncio.get_event_loop()\n# Each client connection will create a new protocol instance  \"Router.set_Counter_factory\" is a static method of the Router class. RxTender\ngenerates one of these methods per stream declared in the rxt file. We will\nwrite the create_counter_stream function later. We will now create a Router\nobject each time a new connection is made:  def connection_made(self, transport):\n    peername = transport.get_extra_info('peername')\n    print('Connection from {}'.format(peername))\n+    self.router = Router(FramedTransport(transport))\n+    self.frame_context = ''  The router object contains the implementation that routes network messages\nto/from streams. It is also in charge of (de)serializing these messages. Its\nconstructor takes a transport object as an argument. This transport object must\nimplement a \"write\" method to write data on the network connection. Note that we\ndid not use the \"transport\" argument directly: Since we use TCP (a stream based\nprotocol), we need add framing on top of it so that we receive messages\ncorrectly. This is what is done by the FramedTransport class:  class FramedTransport(object):\n    def __init__(self, transport):\n        self.transport = transport\n\n    def write(self, data):\n        self.transport.write(frame(data).encode())  In the write method, each message is \"framed\" with the JSON-lines protocol\nbefore being sent. On the other way, all received packets are \"unframed\" before\nthey are provided to the Router:  def data_received(self, data):\n+    message = data.decode()\n+    self.frame_context, packets = unframe(self.frame_context, message)\n+    for packet in packets:\n+        self.router.on_message(packet)  From that point we created a Router, it receives all messages from the network\nand can send messages. We finally need to implement create_counter_stream that\nwill be called each time a new stream subscription request comes:  def delete_counter_subscription(stream):\n    stream = None\n\ndef create_counter_stream(start, end, step):\n    source = Observable.from_(range(start,end+1, step)).map(\n        lambda i: CounterItem(i))\n    return lambda n,c,e: subscribe_counter_stream(source, n, c, e), lambda: delete_counter_subscription(source)\n\ndef subscribe_counter_stream(stream, next, completed, error):\n    stream.subscribe(\n        lambda i: next(i),\n        lambda e: error(e),\n        lambda: completed())  create_counter_stream takes 3 arguments as input: The ones that we specified in the rxt file. It returns 2 functions:   A function to subscribe to this stream  A function to delete this stream   The subscription function is called with 3 function arguments (next, error,\ncompleted). Each time the corresponding event occurs on the source stream, then\nthese functions must be called to forward the event on the transport layer.  Here is the complete code of the server. Save it to a file named \"server.py\":  import asyncio\n\nfrom rx import Observable\nfrom counter_rxt import frame, unframe, Router, CounterItem\n\nclass FramedTransport(object):\n    def __init__(self, transport):\n        self.transport = transport\n\n    def write(self, data):\n        self.transport.write(frame(data).encode())\n\nclass CounterServerProtocol(asyncio.Protocol):\n    def connection_made(self, transport):\n        peername = transport.get_extra_info('peername')\n        print('Connection from {}'.format(peername))\n        self.router = Router(FramedTransport(transport))\n        self.frame_context = ''\n\n    def connection_lost(self, exc):\n        print('connection lost')\n        return\n\n    def data_received(self, data):\n        message = data.decode()\n        self.frame_context, packets = unframe(self.frame_context, message)\n        for packet in packets:\n            self.router.on_message(packet)\n\ndef delete_counter_subscription(stream):\n    stream = None\n\ndef create_counter_stream(start, end, step):\n    source = Observable.from_(range(start,end+1, step)).map(\n        lambda i: CounterItem(i))\n    return lambda n,c,e: subscribe_counter_stream(source, n, c, e), lambda: delete_counter_subscription(source)\n\ndef subscribe_counter_stream(stream, next, completed, error):\n    stream.subscribe(\n        lambda i: next(i),\n        lambda e: error(e),\n        lambda: completed())\n\nRouter.set_Counter_factory(create_counter_stream)\nloop = asyncio.get_event_loop()\n# Each client connection will create a new protocol instance\ncoro = loop.create_server(CounterServerProtocol, '127.0.0.1', 9999)\nserver = loop.run_until_complete(coro)\n\nprint('Serving on {}'.format(server.sockets[0].getsockname()))\ntry:\n    loop.run_forever()\nexcept KeyboardInterrupt:\n    pass\n\nserver.close()\nloop.run_until_complete(server.wait_closed())\nloop.close()",
            "title": "The python server"
        },
        {
            "location": "/get_started/#nodejs-client",
            "text": "For the nodejs client, we start with a TCP client, implemented as a function\nthat returns a stream of stream:  import {Observable, Subject} from 'rxjs';\nimport {Socket} from 'net';\nlet connection = [];\n\nfunction createConnection(id, host, port) {\n  const state$ = Observable.create(stateObserver => {\n    let dataObserver = null;\n    const data$ = Observable.create(observer => {\n      dataObserver = observer;\n    });\n\n    connection[id] = new Socket();\n    connection[id].setEncoding('utf8');\n    connection[id].connect(port, host, function() {\n        console.log('CONNECTED TO: ' + host + ':' + port);\n        stateObserver.next({\n          \"linkId\": id,\n          \"stream\": data$\n        })\n    });\n\n    connection[id].on('data', function(data) {\n      dataObserver.next(data);\n    });\n\n    connection[id].on('close', function() {\n        dataObserver.complete();\n        stateObserver.complete();\n        connection.splice(id, 1);\n    });\n  });\n\n  return state$;\n}  This function returns a stream that emits a stream when the connection is\nestablished. This latter stream then emits items each time some data is received\non the socket. This function is used from a factory function that takes another\nstream as input:  function tcpClient(sink$) {\n  sink$.subscribe( (i) => {\n    connection[i.linkId].write(i.data);\n  });\n\n  return {\n    \"connect\" : createConnection\n  };\n}  Each item of the sink stream contains the data to write on the tcp socket.\nWe will also use log function:  function consoleDriver(sink$) {\n  sink$.subscribe( (i) => {\n    console.log('console: ' + i);\n  });\n}  Now we can implement our logic:  import { router } from './counter_rxt.js';\n\nfunction main(sources) {\n  const linkRcv$ = sources.LINK.connect('counter', 'localhost', 9999);\n  const returnChannel$ = sources.ROUTER.linkData();\n  const console$ = sources.ROUTER.link()\n    .map( i => {\n      return sources.ROUTER.Counter(i.linkId, 1,10,1)\n    })\n    .mergeAll()\n    .map( i => i.value);;\n\n  return {\n   ROUTER: linkRcv$,\n   LINK: returnChannel$,\n   CONSOLE: console$\n  };\n}  The sources parameter contains objects returned by the tcp client factory, the\nconsole factory, and the router factory. This main function creates a Counter\nobservable when the tcp connection is established, i.e. when an item is emitted\non the sources.ROUTER.link() stream. The result of the counter is returned in\nthe CONSOLE field, and will be connected to the console output.  All streams are finally connected together:  const consoleProxy$ = new Subject();\nconst routerProxy$ = new Subject();\nconst linkProxy$ = new Subject();\n\nconst sources = {\n  CONSOLE: consoleDriver(consoleProxy$),\n  ROUTER: router(routerProxy$),\n  LINK: tcpClient(linkProxy$)\n};\n\nconst sinks = main(sources);\n\nsinks.ROUTER.subscribe(routerProxy$);\nsinks.LINK.subscribe(linkProxy$);\nsinks.CONSOLE.subscribe(consoleProxy$);  Here is the complete code of the client. Save it to a file named\n\"client.es6.js\":  import {Observable, Subject} from 'rxjs';\nimport {\n  router,\n} from './counter_rxt.js';\nimport {Socket} from 'net';\n\nlet connection = [];\n\nfunction createConnection(id, host, port) {\n  const state$ = Observable.create(stateObserver => {\n    let dataObserver = null;\n    const data$ = Observable.create(observer => {\n      dataObserver = observer;\n    });\n\n    connection[id] = new Socket();\n    connection[id].setEncoding('utf8');\n    connection[id].connect(port, host, function() {\n        console.log('CONNECTED TO: ' + host + ':' + port);\n        stateObserver.next({\n          \"linkId\": id,\n          \"stream\": data$\n        })\n    });\n\n    connection[id].on('data', function(data) {\n      dataObserver.next(data);\n    });\n\n    connection[id].on('close', function() {\n        dataObserver.complete();\n        stateObserver.complete();\n        connection.splice(id, 1);\n    });\n  });\n\n  return state$;\n}\n\nfunction tcpClient(sink$) {\n  sink$.subscribe( (i) => {\n    connection[i.linkId].write(i.data);\n  });\n\n  return {\n    \"connect\" : createConnection\n  };\n}\n\nfunction consoleDriver(sink$) {\n  sink$.subscribe( (i) => {\n    console.log('console: ' + i);\n  });\n}\n\nfunction main(sources) {\n  const linkRcv$ = sources.LINK.connect('counter', 'localhost', 9999);\n  const returnChannel$ = sources.ROUTER.linkData();\n  const console$ = sources.ROUTER.link()\n    .map( i => {\n      return sources.ROUTER.Counter(i.linkId, 1,10,1)\n    })\n    .mergeAll()\n    .map( i => i.value);;\n\n  return {\n   ROUTER: linkRcv$,\n   LINK: returnChannel$,\n   CONSOLE: console$\n  };\n}\n\nconst consoleProxy$ = new Subject();\nconst routerProxy$ = new Subject();\nconst linkProxy$ = new Subject();\n\nconst sources = {\n  CONSOLE: consoleDriver(consoleProxy$),\n  ROUTER: router(routerProxy$),\n  LINK: tcpClient(linkProxy$)\n};\n\nconst sinks = main(sources);\n\nsinks.ROUTER.subscribe(routerProxy$);\nsinks.LINK.subscribe(linkProxy$);\nsinks.CONSOLE.subscribe(consoleProxy$);",
            "title": "NodeJS client"
        },
        {
            "location": "/get_started/#running-it-all",
            "text": "Now that all code is there, let's start both components. We will first Build the\npython bindings. First install the base backend on your system:  pip3 install rxt-backend-base  Then generate the proxy code corresponding to the Counter IDL:  rxtender \\\n--framing rxt_backend_base.python3.framing.newline \\\n--serialization rxt_backend_base.python3.serialization.json \\\n--stream rxt_backend_base.python3.stream \\\n--input counter.rxt --output counter_rxt.py  rxtender is invoked with 3 generation arguments (framing, serialization, and\nstream). Each parameter corresponds to an available code generator in the\nbackend.  Then we build the javascript bindings. In order to ease generation and\ntranslation from es6 to es5 we use npm with babel:  Javascript NPM package.json:  {\n  \"name\": \"counter-example\",\n  \"version\": \"0.2.0\",\n  \"description\": \"es2015/python3 rxtender counter example\",\n  \"license\": \"MIT\",\n  \"main\": \"client.js\",\n  \"scripts\": {\n    \"generate:counter\": \"rxtender --framing rxt_backend_base.es2015.framing.newline --serialization rxt_backend_base.es2015.serialization.json --stream rxt_backend_base.es2015_rxjs.stream --input counter.rxt --output counter_rxt.es6.js\",\n    \"build:counter\": \"npm run generate:counter && babel --presets es2015 counter_rxt.es6.js --out-file counter_rxt.js\",\n    \"build:client\": \"npm run build:counter && babel --presets es2015 client.es6.js --out-file client.js\",\n    \"build\": \"npm run build:client\",\n    \"start\": \"node client.js\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"babel-cli\": \"^6.24.1\",\n    \"babel-core\": \"^6.25.0\",\n    \"babel-preset-es2015\": \"^6.24.1\",\n    \"rxjs\": \"^5.4.3\"\n  }\n}  The stream argument provided to rxtender generates an es2015 rxjs router\nfunction. Since we use a TCP connection, and TCP is a stream protocol, we need\nsome framing to encapsulate each item of the stream. Here we use new lines\nframing, as specified with the framing argument. With the serialization argument\nwe asked rxtender to generate json serialization of all structs defined in the\nIDL. To generate the code, install npm dependencies and run rxtender:  npm install\nnpm run build  Now everything is ready, we can start the python server:  python3 server.py  and run the javascript client:  npm start  You should get the following output:  > counter-example@0.2.0 start /Users/bipbip/Documents/devel/rxtender/test\n> node client.js\n\nCONNECTED TO: 127.0.0.1:9999\ncreating observable\ntick: 1\ntick: 2\ntick: 3\ntick: 4\ntick: 5\ntick: 6\ntick: 7\ntick: 8\ntick: 9\ntick: 10\ncompleted  Yeah! With only few lines of codes you used reactive streams to communicate\nbetween two processes written in different programming languages. You can now\nadd other streams in the rxt file. All these streams will be multiplexed in\nthe same socket. Moreover, if you want to change the serialization or framing\nprotocol, then you do not need to change anything in your code: Just select\nother ones when invoking rxtender.",
            "title": "Running it all"
        },
        {
            "location": "/com_pattern/",
            "text": "Publish Subscribe\n\n\n\n\nRequest Response\n\n\n\n\nTrigger Publish",
            "title": "Communication Patterns"
        },
        {
            "location": "/com_pattern/#publish-subscribe",
            "text": "",
            "title": "Publish Subscribe"
        },
        {
            "location": "/com_pattern/#request-response",
            "text": "",
            "title": "Request Response"
        },
        {
            "location": "/com_pattern/#trigger-publish",
            "text": "",
            "title": "Trigger Publish"
        },
        {
            "location": "/language/",
            "text": "The RxTender IDL syntax is heavily inspired from the\n\nrust\n language.\n\n\n\n\nunstable\n\n\nThe syntax is not stable yet. Everything documented here can\nchange in the future.\n\n\n\n\nDefining an Item and an Error\n\n\nItem and error types are declared as structures:\n\n\nstruct Status {\n    id :string;\n    value :int32;\n}\n\n\n\nIn this example id and value are two fields of the Status structure. This can\ncan then be used to send items or notify errors on a stream.\n\n\nScalar Types\n\n\n\n\n\n\n\n\nType\n\n\nDefinition\n\n\nDefault value\n\n\n\n\n\n\n\n\n\n\nbool\n\n\nA boolean\n\n\nfalse\n\n\n\n\n\n\ndouble\n\n\nA double precision real number\n\n\n0.0\n\n\n\n\n\n\ni32\n\n\nA signed 32bits integer\n\n\n0\n\n\n\n\n\n\nu32\n\n\nAn unsigned 32bits integer\n\n\n0\n\n\n\n\n\n\ni64\n\n\nA signed 64bits integer\n\n\n0\n\n\n\n\n\n\nu64\n\n\nAn unsigned 32bits integer\n\n\n0\n\n\n\n\n\n\nstring\n\n\nAn UTF8 string\n\n\nempty string\n\n\n\n\n\n\n\n\nDefining A Stream\n\n\nA stream is declared the following way.\n\n\nstream State() -> Stream<I, E>;\n\n\n\nwhere State is the name of the Stream, \"I\" is the type of the items, and E the\ntype of the error. I and E must be declared as structs. A stream can also accept\ncreation arguments:\n\n\nstream State(foo: u32, bar: u32) -> Status;\n\n\n\nNaming convention\n\n\nitems and streams are CamelCase.",
            "title": "Language"
        },
        {
            "location": "/language/#defining-an-item-and-an-error",
            "text": "Item and error types are declared as structures:  struct Status {\n    id :string;\n    value :int32;\n}  In this example id and value are two fields of the Status structure. This can\ncan then be used to send items or notify errors on a stream.",
            "title": "Defining an Item and an Error"
        },
        {
            "location": "/language/#scalar-types",
            "text": "Type  Definition  Default value      bool  A boolean  false    double  A double precision real number  0.0    i32  A signed 32bits integer  0    u32  An unsigned 32bits integer  0    i64  A signed 64bits integer  0    u64  An unsigned 32bits integer  0    string  An UTF8 string  empty string",
            "title": "Scalar Types"
        },
        {
            "location": "/language/#defining-a-stream",
            "text": "A stream is declared the following way.  stream State() -> Stream<I, E>;  where State is the name of the Stream, \"I\" is the type of the items, and E the\ntype of the error. I and E must be declared as structs. A stream can also accept\ncreation arguments:  stream State(foo: u32, bar: u32) -> Status;",
            "title": "Defining A Stream"
        },
        {
            "location": "/language/#naming-convention",
            "text": "items and streams are CamelCase.",
            "title": "Naming convention"
        },
        {
            "location": "/backend_base/",
            "text": "Serialization\n\n\nJSON\n\n\nCreation message:\n\n\n{\n    \"title\": \"Create Message\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"what\": {\n            \"description\": \"the message type. Value is 'create'\",\n            \"type\": \"string\"\n        },\n        \"streamType\": {\n            \"description\": \"The type of stream to create\",\n            \"type\": \"string\"\n        },\n        \"streamId\": {\n          \"description\": \"Id of the stream to create\",\n          \"type\": \"number\"\n        },\n        \"args\": {\n          \"description\": \"arguments used to create the stream\",\n          \"type\": \"array\"\n        }\n    },\n    \"required\": [\"what\", \"streamType\", \"streamId\", \"args\"]\n}\n\n\n\nexample:\n\n\n{\n    \"what\": \"create\",\n    \"streamType\": \"ClockTickStream\",\n    \"id\": 42,\n    \"args\": []\n}\n\n\n\nCreation success message:\n\n\nexample:\n\n\n{\n    \"what\": \"createAck\",\n    \"streamId\": 42\n}\n\n\n\nCreation failure message:\n\n\nexample:\n\n\n{\n    \"what\": \"createNack\",\n    \"streamId\": 42,\n    \"reason\": \"nomem\"\n}\n\n\n\nDeletion message:\n\n\n{\n    \"title\": \"Delete Message\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"what\": {\n            \"description\": \"the message type. Value is 'delete'\",\n            \"type\": \"string\"\n        },\n        \"streamId\": {\n          \"description\": \"Id of the stream to delete\",\n          \"type\": \"number\"\n        }\n    },\n    \"required\": [\"what\", \"streamId\"]\n}\n\n\n\nexample:\n\n\n{\n    \"what\": \"delete\",\n    \"id\": 42\n}\n\n\n\nDeletion success message:\n\n\nexample:\n\n\n{\n    \"what\": \"deleteAck\",\n    \"streamId\": 42\n}\n\n\n\nNext item message:\n\n\n{\n    \"title\": \"Next Message\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"what\": {\n            \"description\": \"the message type. Value is 'next'\",\n            \"type\": \"string\"\n        },\n        \"item\": {\n            \"description\": \"the serialized item\",\n            \"type\": \"object\"\n        },\n    },\n    \"required\": [\"what\", \"item\"]\n}\n\n\n\nexample:\n\n\n{\n    \"what\": \"next\",\n    \"item\": {\n        \"foo\": 42,\n        \"bar\": \"buzz\"\n      }\n}\n\n\n\nCompleted message:\n\n\n{\n    \"title\": \"Completed Message\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"what\": {\n            \"description\": \"the message type. Value is 'completed'\",\n            \"type\": \"string\"\n        },\n    },\n    \"required\": [\"what\"]\n}\n\n\n\nexample:\n\n\n{\n    \"what\": \"completed\"\n}\n\n\n\nError message:\n\n\n{\n    \"title\": \"Error Message\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"what\": {\n            \"description\": \"the message type. Value is 'error'\",\n            \"type\": \"string\"\n        },\n        \"message\": {\n            \"description\": \"A message containing information about the error\",\n            \"type\": \"string\"\n        },\n    },\n    \"required\": [\"what\", \"message\"]\n}\n\n\n\nexample:\n\n\n{\n    \"what\": \"completed\"\n}\n\n\n\nPython\n\n\nES2015",
            "title": "Base Backend"
        },
        {
            "location": "/backend_base/#serialization",
            "text": "",
            "title": "Serialization"
        },
        {
            "location": "/backend_base/#json",
            "text": "Creation message:  {\n    \"title\": \"Create Message\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"what\": {\n            \"description\": \"the message type. Value is 'create'\",\n            \"type\": \"string\"\n        },\n        \"streamType\": {\n            \"description\": \"The type of stream to create\",\n            \"type\": \"string\"\n        },\n        \"streamId\": {\n          \"description\": \"Id of the stream to create\",\n          \"type\": \"number\"\n        },\n        \"args\": {\n          \"description\": \"arguments used to create the stream\",\n          \"type\": \"array\"\n        }\n    },\n    \"required\": [\"what\", \"streamType\", \"streamId\", \"args\"]\n}  example:  {\n    \"what\": \"create\",\n    \"streamType\": \"ClockTickStream\",\n    \"id\": 42,\n    \"args\": []\n}  Creation success message:  example:  {\n    \"what\": \"createAck\",\n    \"streamId\": 42\n}  Creation failure message:  example:  {\n    \"what\": \"createNack\",\n    \"streamId\": 42,\n    \"reason\": \"nomem\"\n}  Deletion message:  {\n    \"title\": \"Delete Message\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"what\": {\n            \"description\": \"the message type. Value is 'delete'\",\n            \"type\": \"string\"\n        },\n        \"streamId\": {\n          \"description\": \"Id of the stream to delete\",\n          \"type\": \"number\"\n        }\n    },\n    \"required\": [\"what\", \"streamId\"]\n}  example:  {\n    \"what\": \"delete\",\n    \"id\": 42\n}  Deletion success message:  example:  {\n    \"what\": \"deleteAck\",\n    \"streamId\": 42\n}  Next item message:  {\n    \"title\": \"Next Message\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"what\": {\n            \"description\": \"the message type. Value is 'next'\",\n            \"type\": \"string\"\n        },\n        \"item\": {\n            \"description\": \"the serialized item\",\n            \"type\": \"object\"\n        },\n    },\n    \"required\": [\"what\", \"item\"]\n}  example:  {\n    \"what\": \"next\",\n    \"item\": {\n        \"foo\": 42,\n        \"bar\": \"buzz\"\n      }\n}  Completed message:  {\n    \"title\": \"Completed Message\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"what\": {\n            \"description\": \"the message type. Value is 'completed'\",\n            \"type\": \"string\"\n        },\n    },\n    \"required\": [\"what\"]\n}  example:  {\n    \"what\": \"completed\"\n}  Error message:  {\n    \"title\": \"Error Message\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"what\": {\n            \"description\": \"the message type. Value is 'error'\",\n            \"type\": \"string\"\n        },\n        \"message\": {\n            \"description\": \"A message containing information about the error\",\n            \"type\": \"string\"\n        },\n    },\n    \"required\": [\"what\", \"message\"]\n}  example:  {\n    \"what\": \"completed\"\n}",
            "title": "JSON"
        },
        {
            "location": "/backend_base/#python",
            "text": "",
            "title": "Python"
        },
        {
            "location": "/backend_base/#es2015",
            "text": "",
            "title": "ES2015"
        },
        {
            "location": "/backend_dev/",
            "text": "Principles\n\n\nA RxTender backend is a python package that contains jinja2 templates. A backend\ncan implement one, several, or all features of RxTender : Framing,\nserialization, and router. Each of these features is implemented as several\ntemplate files. The following figure shows how code is generated:\n\n\n\n\nRxTender takes an rxt definition file as input. It then generates chunks of code\nfrom each template file being used. Finally, all chunks of code are combined to\ngenerate a final file.\n\n\nBackend Structure\n\n\npython package, jinja2 template engine for code generation.\n\n\nThe source layout of a backend is the following one:\n\n\nrtx_backend_foo\n    /[language[_framework]]            \n        /framing\n        /serialization\n        /stream\n\n\n\nwhere foo is the name of the backend, [language] is the name of a programming\nlanguage. There is one [language] module per programming language supported by\nthe backend. An optional \"framework\" name can be provided if different\nframeworks of a language are supported and they must generate different code.\n\n\nAll templates follow the same naming convention:\n\n\n\n\n[output type].[template type].tpl\n\n\n\n\n[output type] is the type of file to generate. All backends implement the\n\"source\" output type. The \"source\" templates generate source code. If the\nselected language also needs other files types to be generated, then additional\noutput type templates can be implemented. For example, with C or C++ a header\nfile is also needed. So, these languages also implement \"header\" output types. So\na backend with support for c contains \"source.content.tpl\" and \"header.content.tpl\"\ntemplates in the serialization modules.\n\n\nMessages\n\n\n\n\nstream creation request\n\n\nstream creation ack\n\n\nstream creation nack\n\n\nstream deletion request\n\n\nstream deletion ack\n\n\nnext item publish\n\n\nstream complete\n\n\nstream error\n\n\n\n\nTemplates\n\n\n\n\nheader.tpl\n\n\ncontent.tpl\n\n\nfooter.tpl\n\n\n\n\nStreams\n\n\nStreams generate Observables proxies that follow the \nObservable Contract",
            "title": "Backend Development"
        },
        {
            "location": "/backend_dev/#principles",
            "text": "A RxTender backend is a python package that contains jinja2 templates. A backend\ncan implement one, several, or all features of RxTender : Framing,\nserialization, and router. Each of these features is implemented as several\ntemplate files. The following figure shows how code is generated:   RxTender takes an rxt definition file as input. It then generates chunks of code\nfrom each template file being used. Finally, all chunks of code are combined to\ngenerate a final file.",
            "title": "Principles"
        },
        {
            "location": "/backend_dev/#backend-structure",
            "text": "python package, jinja2 template engine for code generation.  The source layout of a backend is the following one:  rtx_backend_foo\n    /[language[_framework]]            \n        /framing\n        /serialization\n        /stream  where foo is the name of the backend, [language] is the name of a programming\nlanguage. There is one [language] module per programming language supported by\nthe backend. An optional \"framework\" name can be provided if different\nframeworks of a language are supported and they must generate different code.  All templates follow the same naming convention:   [output type].[template type].tpl   [output type] is the type of file to generate. All backends implement the\n\"source\" output type. The \"source\" templates generate source code. If the\nselected language also needs other files types to be generated, then additional\noutput type templates can be implemented. For example, with C or C++ a header\nfile is also needed. So, these languages also implement \"header\" output types. So\na backend with support for c contains \"source.content.tpl\" and \"header.content.tpl\"\ntemplates in the serialization modules.",
            "title": "Backend Structure"
        },
        {
            "location": "/backend_dev/#messages",
            "text": "stream creation request  stream creation ack  stream creation nack  stream deletion request  stream deletion ack  next item publish  stream complete  stream error",
            "title": "Messages"
        },
        {
            "location": "/backend_dev/#templates",
            "text": "header.tpl  content.tpl  footer.tpl",
            "title": "Templates"
        },
        {
            "location": "/backend_dev/#streams",
            "text": "Streams generate Observables proxies that follow the  Observable Contract",
            "title": "Streams"
        }
    ]
}